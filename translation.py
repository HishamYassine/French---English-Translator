# -*- coding: utf-8 -*-
"""Machine Translation (ENG-FR).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uPdoYXH538nXV3qEyMfAdRFc-w6oABff

##Machine Translation Using a Seq2Seq Architecture
Â© 2022 Zaka AI, Inc. All Rights Reserved.

---
The goal of this colab is to get you more familiar with the Seq2Seq models and their challenges. For this reason, you will be working on machine translation problem where we would have a sentence as input (in english), and the output is gonna be the translated sentence (in french). So just like what happens with Google Translate.

**Just to give you a heads up:** We won't be having a model performing like Google translate, but at least we will have an idea about how Google Translate works and the challenges that exist with a translation problem.

## Importing Libraries

We start by importing numpy and pandas and then we can add the rest
"""

import pandas as pd
import numpy as np
import tensorflow as tf

"""We clone the github repository where our data exists. Here is the github link: https://github.com/zaka-ai/machine_learning_certification/tree/main/Challenge%207

## Getting the data
"""

#Test Your Zaka
en_url= 'https://raw.githubusercontent.com/zaka-ai/machine_learning_certification/main/Challenge%207/en.csv'
fr_url= 'https://raw.githubusercontent.com/zaka-ai/machine_learning_certification/main/Challenge%207/fr.csv'

"""We read the english sentences in a dataframe named "english", and the french sentences in a dataframe named "french"
"""

#Test Your Zaka (English)
english = pd.read_csv(en_url)
english.head()

#Test Your Zaka (French)
french= pd.read_csv(fr_url)
french.head()

"""**How many sentences does each of the files contain?**"""

#Test Your Zaka
print('We have', english.shape[0],'sentences in the English corpus | and we have',french.shape[0],'sentences in the French corpus' )

"""Now let us concatenate the 2 dataframes into one dataframe that we call **df** where one column has the english senetnces and the other has the french sentences"""

#Test Your Zaka
df=english.join(french)

"""Let's name the columns as **English** and **French** so that we access them easier."""

#Test Your Zaka
df.columns=['English','French']
df.head()

"""Pick a sentence and print it in both languages"""

#Test Your Zaka
print(df.loc[10000])

"""##Cleaning Data

The data that we have is almost clean as we can see, we just need to remove the punctuations inside of it.
"""

#Test Your Zaka
import string

def remove_punctuations(text):
   for punctuation in string.punctuation: 
     text = text.replace(punctuation, '')
   return text

df['English']=df['English'].apply(remove_punctuations)
df['French']=df['French'].apply(remove_punctuations)

df.head()

"""Make sure that the punctuation is removed by printing the example that you printed earlier."""

pd.options.display.max_colwidth = 100
print(df.loc[10000])

"""##Exploring the Data

Add a column **ENG Length** to the dataset that shows how many words does a sentence contain, and do the same for french in a column called **FR Length**
"""

#Test Your Zaka
df['ENG Length'] = df['English'].str.split().str.len()
df['FR Length'] = df['French'].str.split().str.len()
df.head()

"""Visualize the distribution of the lengths of english sentences and french sentences."""

#Test Your Zaka
import matplotlib.pyplot as plt

fig, axes = plt.subplots(1,2,figsize=(10,5))

df.hist('ENG Length', ax=axes[0], bins=5)
df.hist('FR Length', ax=axes[1], bins=5)

#df['ENG Length'].plot(kind='hist')

"""Get the maximum length of an english sentence and the maximum length of a french sentence. """

#Test Your Zaka
print('Maximum Length of an English Sentence is:',df['ENG Length'].max())
print('Maximum Length of a French Sentence is:',df['FR Length'].max())

"""##Preprocessing the Data

In order for the data to be fed to the model, it has to be tokenized and padded.

####Tokenization

**To tokenize english and french sentences, we can use only one tokenizer. True or False?**

**Answer:**

**[False, we can create as many tokenizers as we need (as objects) from the class Tokenizer]**

Tokenize the sentences that we have.
"""

#Test Your Zaka
# function to build a tokenizer
from tensorflow.keras.preprocessing.text import Tokenizer

def tokenization (sentences):
  tokenizer=Tokenizer()
  tokenizer.fit_on_texts(sentences)
  
  return tokenizer

# prepare English tokenizer
eng_tokenizer=tokenization(df['English'])
eng_vocab_size = len(eng_tokenizer.word_index) + 1

# prepare French tokenizer
fr_tokenizer= tokenization(df['French'])
fr_vocab_size = len(fr_tokenizer.word_index) + 1

"""**How many unique words do we have in english and in french?**"""

print('Unique Words in English sentences:',len(eng_tokenizer.word_index))
print('Unique Words in French sentences:',len(fr_tokenizer.word_index))

"""### Padding

**What should be the length of the sequences that we have after padding?**

**[For English sequences, we should have a length of 15 (The maximum length of an English sentence). For French sequences, we should have a length of 21]**

Perform padding on the sequences that we have.
"""

#Test Your Zaka
from tensorflow.keras.preprocessing.sequence import pad_sequences

eng_tokens =  eng_tokenizer.texts_to_sequences(df['English'])
fr_tokens = fr_tokenizer.texts_to_sequences(df['French'])

# pad sequences
max_length_eng = 15
max_length_fr=21

# Applying post-padding to the sequences
eng_pad = pad_sequences(eng_tokens, maxlen=max_length_eng, padding='post') # my x output
fr_pad = pad_sequences(fr_tokens, maxlen=max_length_fr, padding='post')# my y output

eng_pad

"""##Modeling

After preprrocessing the data, we can build our model. Start by building a baseline architecture relying on one directional RNNs, LSTMs, or GRUs. It will be good to lookup how to build Seq2Seq models, there are some new layers that will help you like RepeatVector and TimeDistributed.
"""

from keras import optimizers
from keras.models import Model
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, LSTM, Dense, RepeatVector, TimeDistributed, Bidirectional, Input
import tensorflow as tf

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(eng_pad, fr_pad, test_size=0.2, random_state= 42)

# Instantiate the model 
model = Sequential() 
# Embeding layer for input language 
model.add(Embedding(eng_vocab_size, 256, input_length=max_length_eng, mask_zero=True))
# Add LSTM layer 
model.add(LSTM(256)) 
# Repeat the last vector
model.add(RepeatVector(max_length_fr))
# Right after the encoder 
model.add(LSTM(256, return_sequences=True)) # Add Time Distributed
model.add(TimeDistributed(Dense(fr_vocab_size, activation='softmax')))

model.summary()

"""Compile and train the model. 
**FYI:** While specifying the architecture of your model and the number of epochs for training, keeep in your mind that your model might take A LOT of time to train.
"""

#Test Your Zaka
#Compiling
import tensorflow as tf
model.compile(optimizer='adam',loss = 'sparse_categorical_crossentropy', metrics=['accuracy'])

y_train = np.expand_dims(y_train, axis = 2)
y_train.shape
print(y_train.shape)

history= model.fit(x_train,
                   y_train,
                   batch_size=128,
                   validation_split = 0.2,
                   epochs=25,
                   verbose=1
                            )

"""Define a function that gets an input sentence in english and gives the output sentence in the french language."""

def prepare_input(input_text):
  e1= eng_tokenizer.texts_to_sequences([input_text])
  e2= pad_sequences(e1, maxlen=max_length_eng, padding='post')
  return e2

# function to make prediction
def prediction(x, x_tokenizer = eng_tokenizer, y_tokenizer = fr_tokenizer):
    predictions = model.predict(x)[0]
    id_to_word = {id: word for word, id in y_tokenizer.word_index.items()}
    id_to_word[0] = ''
    return ' '.join([id_to_word[j] for j in np.argmax(predictions,1)])

def eng_fr_translate(input_text):
  padded= prepare_input(input_text)
  predicted_text=prediction(padded)
  return predicted_text

"""Test the following sentence"""

input = "she is driving the truck"
sequences= eng_tokenizer.texts_to_sequences([input])
padded=pad_sequences(sequences, maxlen=max_length_eng, padding='post')
prediction(padded)

"""**[OR]**"""

input = "she is driving the truck"
eng_fr_translate(input)

"""Try to improve your model by modifying the architecture to take into account bidirectionality which is very useful in Machine Translation. Create a new model called model2"""

#Test Your Zaka
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, LSTM, Dense, RepeatVector, TimeDistributed, Bidirectional

from tensorflow.keras.layers import Bidirectional

# Instantiate the model 
model2 = Sequential() 
# Embeding layer for input language 
model2.add(Embedding(eng_vocab_size, 256, input_length=max_length_eng, mask_zero=True))
# Adding Bidirectional layer
model2.add(Bidirectional(LSTM(256), merge_mode="concat", weights=None, backward_layer=None))
# Repeat the last vector
model2.add(RepeatVector(max_length_fr))
# Right after the encoder 
model2.add(LSTM(256, return_sequences=True)) # Add Time Distributed
model2.add(TimeDistributed(Dense(fr_vocab_size, activation='softmax')))

"""compile and train your new model."""

#Test Your Zaka
#Compiling
import tensorflow as tf
model2.compile(optimizer='adam',loss = 'sparse_categorical_crossentropy', metrics=['accuracy'])

#Fitting our model
history2 = model2.fit(x_train, 
          y_train, 
          epochs=25, 
          batch_size=128, 
          validation_split=0.2, 
          verbose=1
          )

"""**Analysis:**
- From the start of learning it was confused since it's getting prediction of the input (backword) and input at the same time, but by the time it learning faster than the last model (model1)

Define a new function that relies on your new model to make predictions.
"""

# function to make prediction
def prediction2(x, x_tokenizer = eng_tokenizer, y_tokenizer = fr_tokenizer):
    predictions = model2.predict(x)[0]
    id_to_word = {id: word for word, id in y_tokenizer.word_index.items()}
    id_to_word[0] = ''
    return ' '.join([id_to_word[j] for j in np.argmax(predictions,1)])

def eng_fr_translate2(input_text):
  padded= prepare_input(input_text)
  predicted_text=prediction2(padded)
  return predicted_text

#Test Your Zaka
input = "she is driving the truck"
sequences= eng_tokenizer.texts_to_sequences([input])
padded=pad_sequences(sequences, maxlen=max_length_eng, padding='post')
prediction2(padded)

"""**[OR]**"""

input = "she is driving the truck"
eng_fr_translate2(input)

"""**What is another adjustment in terms of architecture that you might be able to do to improve your model?**

- [Adding Dropout]
- [Decreasing LSTM number]

**These 2 steps will reduce the complexity of the model architecture, so that will be avoiding the overfitting of the model**

**Additional:**
- [Adding Attention]
"""

from tensorflow.keras.layers import Bidirectional, Dropout

# Instantiate the model 
model3 = Sequential() 
# Embeding layer for input language 
model3.add(Embedding(eng_vocab_size, 128, input_length=max_length_eng, mask_zero=True))
# Adding Dropout layer
model3.add(Dropout(0.2))
# Adding Bidirectional layer
model3.add(Bidirectional(LSTM(128), merge_mode="concat", weights=None, backward_layer=None))
# Repeat the last vector
model3.add(RepeatVector(max_length_fr))
# Right after the encoder 
model3.add(LSTM(128, return_sequences=True)) # Add Time Distributed
# Adding Dropout layer
model3.add(Dropout(0.2))
model3.add(TimeDistributed(Dense(fr_vocab_size, activation='softmax')))

#Test Your Zaka
#Compiling
import tensorflow as tf
model3.compile(optimizer='adam',loss = 'sparse_categorical_crossentropy', metrics=['accuracy'])

#Fitting our model
history3 = model3.fit(x_train, 
          y_train, 
          epochs=25, 
          batch_size=128, 
          validation_split=0.2, 
          verbose=1
          )

# function to make prediction
def prediction3(x, x_tokenizer = eng_tokenizer, y_tokenizer = fr_tokenizer):
    predictions = model3.predict(x)[0]
    id_to_word = {id: word for word, id in y_tokenizer.word_index.items()}
    id_to_word[0] = ''
    return ' '.join([id_to_word[j] for j in np.argmax(predictions,1)])

def eng_fr_translate3(input_text):
  padded= prepare_input(input_text)
  predicted_text=prediction3(padded)
  return predicted_text

#Test Your Zaka
input = "she is driving the truck"
sequences= eng_tokenizer.texts_to_sequences([input])
padded=pad_sequences(sequences, maxlen=max_length_eng, padding='post')
prediction3(padded)

"""**[OR]**"""

input = "she is driving the truck"
eng_fr_translate3(input)

"""**What are some additional ways that we can do to improve the performance of our model?**

- **[Collecting more data, so the model will be having more vocab size that will be include more words and take a consideration for new word that will be predicting any input in the model and gets an accurate result]**

---------

- **[the samples in the training dataset are somehow related and have a common context. so the model does not have a good diversity to predict new random sentences]**

**Example:**
"""

input = "I want excellent grade please Fouad"
eng_fr_translate3(input)

"""![image.png](data:image/png;base64,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)

ðŸ™‚

- If the data need a more clean processes we do the following

- **[Add Stemming --> make the training process faster]**
- **[Avoid stop word]**
- **[Lowering the case]**
"""